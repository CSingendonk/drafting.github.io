<!DOCTYPE-html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=0.75">
    <title>Super Pong</title>
    <style>
        canvas
        {
            background-color: black;
            border: 1px solid blue;
            display: block;
            margin: auto;
            margin-right: 0.5vmin;
            width: 95vw;
            height: 80vh;
        }

        #scoreLeft
        {
            display: flex;
            position: absolute;
            float:left;
            clear: none;
            top: 1%; 
            bottom: auto;
            left: 0%;
            right: auto;
            width: 0.5vmin;
            height: 6rem;
            font-size: 0.1rem;
        }
            #scoreLeft:hover, #scoreLeft:focus{
                display: flex;
                position: absolute;
                float:left;
                clear: none;
                top: 1%; 
                left: 0%;
                border: 1px black solid;
                padding-inline: 10px;
                width: auto;
                height: 6rem;
                font-size: 4.5rem;
                font-weight: 700;
                text-align: center;
                align-content: stretch;
                justify-content: space-around;
                align-items: stretch;
                color: black;
            }

        #scoreRight
        {
            display: flex;
            position: absolute;
            float:right;
            clear: none;
            top: 1%; 
            bottom: auto;
            right: 0%;
            left: auto;
            width: 0.5vmin;
            height: 6rem;
            font-size: 0.1rem;
        }
            #scoreRight:hover, #scoreRight:focus{
                display: flex;
                position: absolute;
                float:right;
                clear: none;
                top: 1%; 
                right: 0%;
                border: 1px black solid;
                width: auto;
                height: 6rem;
                font-size: 4.5rem;
                font-weight: 700;
                text-align: center;
                align-content: center;
                justify-content:space-around;
                align-items: stretch;
                color: black;
            }


        #settingsDiv * {
            height: 100%;
            display: none;
        }

        #settingsDiv {
            height: 100%;
            width: 100%;
            background-color: orange;
        }
            #settingsDiv:hover, #settingsDiv:focus, #settingsDiv:hover *{
                height: 100%;   
                display: inline;
                content-visibility: visible;
                visibility: visible;

            }
    </style>
</head>
<body>
    <label id="winNumLabel" for="winNumberInput" style="margin: 0 auto 0 auto; font-size:2rem; font-weight:400; display:none; justify-content:center; justify-self:center;"></label>
    <div id="scoreRight">0</div>
    <div id="scoreLeft">0</div>
    <canvas id="canvas" height="420" width="840"> </canvas>
    <div style="
    display: flex;
    margin: auto;
    position: relative;
    align-content: stretch;
    justify-content: center;
    align-items: center;
    flex-wrap: nowrap;
    font-size: 1rem;
    background-color: #111111ff;
">
        <label for="ballSpeed" style="
    color:paleturquoise;
    margin-inline: 50px;
    font-size: 1rem;
    font-weight: 600;
">Ball Speed:</label>
        <input type="number" id="ballSpeed" value="5" style="width: 4%;
    padding-left: 0.25%;
    display: flex;
    max-width: 7.5%;
    justify-content: inherit;
    margin-right: initial;
    user-select: all;
    counter-increment: auto;" />
    </div>
    <div style="
    display: flex;
    margin-inline: 5%;
    position: relative;
    align-content: stretch;
    justify-content: space-around;
    align-items: stretch;
    flex-wrap: nowrap;
    font-size: 3rem;
    background-color: #1111111f;">
 
        <button id="resetButton" margin-left="50%" style="height: fit-content; margin-top: auto; margin-bottom: auto; font-size: 1rem; background-color: #9f0000f5; color: floralwhite;">
            Reset Score
        </button>
    </div>
    <div id="settingsDiv" style="display:inline-flex;">
        <label for="aiCheckbox" style="margin-right: 2vw; border: 5px solid black; font-size: 2rem;">
            AI
            <input type="checkbox" id="aiCheckbox" checked onchange="toggleAI()" style="border: 5px solid black; border-right: 0px none white;" />
        </label>
        <label for="gameModeSelect">Play Style =</label>
        <select id="gameModeSelect" style="width: 30vw; height: 2.5rem; margin: 0 auto; text-align:center; font-size: 2rem; font-weight: 300;">
            <option inert value="default">Select Style</option>
            <option value="twoPaddles">Two Paddles</option>
            <option value="fourPaddles">Four Paddles</option>
        </select>
        <label for="winConditionSelect">Game Mode =</label>
        <div style="display: block; max-width: 30vw;">
            <select id="winConditionSelect" style="width: 100%; height: 2.5rem; margin: 0 auto; text-align:center; font-size: 2rem; font-weight: 300;  ">
                <option value="default">Default</option>
                <option title="Unlimited scoring" value="noWin">No Limit</option>
                <option title="First to score # points wins" value="firstToX">First to #</option>
                <option title="Score more than 50% of # to win" value="bestOfX">Best of #</option>
                <option title="First to score wins" value="deathmatch">Quickmatch</option>
                <option title="Score # times in a row to win" value="domination">No Contest</option>
                <option title="Score the most points in # minutes to win" value="timedMatch">Timed Match</option>
            </select>
            <input type="number" inert id="winNumberInput" min="1" step="1" value="3" name="winNumIn" style="display: inline-flex;font-size: 2rem; font-weight: 400; width:stretch; margin: 0 auto; opacity: 0;" />
        </div>
        <span id="winSubConditionIn">
            <label id="winTimeLabel" for="winTimeInput" style="font-size:2rem; font-weight:400; display:none;"></label>
            <input type="time" id="winTimeInput" name="winTimeIn" style="display: none" />
        </span>
    </div>
    <audio hidden controls="controls" id="snap">
        <source src="Recording%20(5).mp3" type="audio/mp3" />
    </audio>
    <audio hidden controls="controls" id="bounce">
        <source src="Recording%20(5).mp3" type="audio/mp3" />
    </audio>
    <audio hidden controls="controls" id="popmp3">
        <source src="./data/pop.mp3" type="audio/mp3" />
    </audio>
    <audio hidden controls="controls" id="eeoo">
        <source src="./data/eeoootrimmed.mp3" type="audio/mp3" />
    </audio>
    <!-- <script src="c:\users\cps13\source\repos\NodejsWebApp3\pages\css\JavaScript.js"></script>-->
    <script>
        {
            let vsAI = true;
            const pongscript = globalThis;
            const canvas = document.getElementById("canvas"), ctx = canvas.getContext("2d"), snapmp3 = document.getElementById('snap'), ogBallSize = (canvas.width / 6) / 5;
            const ballSpeedInput = document.getElementById("ballSpeed");
            const resetButton = document.getElementById("resetButton");
            const scoreLeftElement = document.getElementById("scoreLeft");
            const scoreRightElement = document.getElementById("scoreRight");
            const scoreLeftDisplay = document.getElementById("scoreLeft");
            const scoreRightDisplay = document.getElementById("scoreRight");
            const gameModeSelect = document.getElementById("gameModeSelect");
            const subConNumLabel = document.getElementById("winNumLabel");
            const winConSelect = document.getElementById("winConditionSelect");
            let gameStarted = false; gameOver = false, gameMode = 'default', powerupsEnabled = true, paddleHeight = canvas.width / 6, paddleWidth = (canvas.height * 2) / paddleHeight, ballSpeed = 3, paddleSpeed = 7.5, paddleFill = 'white', ballSize = canvas.width / (paddleWidth * ballSpeed) / 2, scoreLeft = 0, scoreRight = 0;
            let scoreHistory = [];
            let tbPaddleHeight = paddleHeight, tbPaddleWidth = paddleWidth, tbPaddleFill;
            let leftPaddle = {
                x: 20,
                y: canvas.height / 2 - paddleHeight / 2,
                dy: 0
            };
            let rightPaddle = {
                x: canvas.width - paddleWidth - 20,
                y: canvas.height / 2 - paddleHeight / 2,
                dy: 0
            };
            let topPaddle = {
                wide: paddleHeight,
                high: paddleWidth,
                x: (canvas.width / 2) - (paddleHeight / 2),
                y: paddleWidth * 2,
                dy: 0,
                dx: 0
            };
            let bottomPaddle = {
                wide: paddleHeight,
                high: paddleWidth,
                x: (canvas.width / 2) - (paddleHeight / 2),
                y: canvas.height - (paddleWidth * 2),
                dy: 0,
                dx: 0
            };
            let ball = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                dx: ballSpeed,
                dy: ballSpeed,
                fill: 'white',
                mod: ''
            };
            // Define power-up object
            let powerUp = {
                x: canvas.width / 2, // Initial x position
                y: canvas.height / 2, // Initial y position
                width: ballSize, // Power-up width
                height: ballSize, // Power-up height
                active: true, // Indicates if the power-up is active
                drawn: true, // Is powerUp on canvas
                type: '', // Type of power-up (e.g., 'multiply', 'speedUp', 'speedDown')
            };
            subConNumLabel.textContent = 'New Match: No Limit | 4 Paddles';
            let pwrup = canvas.getContext("2d");
            // Setup score display
            updateScoreDisplay();
            const numericScoreLeft = parseInt(scoreLeftDisplay.textContent);
            const numericScoreRight = parseInt(scoreRightDisplay.textContent);
            scoreLeftElement.style.backgroundColor = (numericScoreLeft > numericScoreRight) ? "green" : (numericScoreLeft < numericScoreRight) ? "red" : "yellow";
            scoreRightElement.style.backgroundColor = (numericScoreLeft < numericScoreRight) ? "green" : (numericScoreLeft > numericScoreRight) ? "red" : "yellow";
            // Setup ball speed input
            ballSpeedInput.addEventListener("input", function () {
                let speed = parseInt(ballSpeedInput.value);
                if (!isNaN(speed)) {
                    ballSpeed = speed;
                    paddleSpeed = ballSpeed * 1.25; // Update paddle speed based on ball speed
                    ball.dx = ballSpeed;
                    ball.dy = ballSpeed;
                }
            });

            function resetScoreDisplays() {
                scoreLeft = 0;
                scoreRight = 0;
                updateScoreDisplay();
            };

            // Setup reset button
            resetButton.addEventListener("click", function () {
                resetScoreDisplays();
            });
            // Draw paddles
            function drawPaddle(x, y) {
                ctx.fillStyle = ball.mod == 'paddleShort' ? 'pink' : (ball.mod == 'paddleTall' ? 'yellow' : 'white');
                ctx.fillRect(x, y, paddleWidth, paddleHeight);
            };
            function drawHorizontalPaddles(x, y) {
                if (gameMode != 'twoPaddles') {
                    ctx.fillStyle = ball.mod == 'paddleShort' ? 'pink' : (ball.mod == 'paddleTall' ? 'yellow' : 'white');
                } else {
                    ctx.fillStyle = 'black';
                }
                ctx.fillRect(y, x, paddleHeight, paddleWidth);
            };
            // Draw ball
            function drawBall(x, y) {
                ctx.beginPath();
                ctx.arc(x, y, ballSize, 0, Math.PI * 2);
                ctx.fillStyle = ball.fill;
                ctx.fill();
                ctx.closePath();
                paddleSpeed = ballSpeed * 1.5;
            }

            function fourPaddles() {
                tbPaddleWidth = paddleHeight;
                tbPaddleHeight = paddleWidth;
                topPaddle.wide = tbPaddleWidth;
                topPaddle.high = tbPaddleHeight;
                topPaddle.x = (canvas.width / 2) - (topPaddle.wide / 2);
                topPaddle.y = topPaddle.high * 2.5;
                bottomPaddle.wide = tbPaddleWidth;
                bottomPaddle.high = tbPaddleHeight;
                bottomPaddle.x = (canvas.width / 2) - (bottomPaddle.wide / 2); // tbPaddleHeight,
                bottomPaddle.y = canvas.height - (bottomPaddle.high * 2);
            }

            function noTopBottomPaddles() {
                tbPaddleWidth = canvas.width;
                tbPaddleHeight = paddleWidth;
                topPaddle.y = topPaddle.high * 2.5;
                topPaddle.x = 0;
                topPaddle.wide = tbPaddleWidth;
                bottomPaddle.y = canvas.height - bottomPaddle.high;
                bottomPaddle.x = 0;
                bottomPaddle.wide = tbPaddleWidth;
            }

            gameModeSelect.addEventListener("change", function () {
                const selectedMode = gameModeSelect.value;
                applyGameMode(selectedMode);
                resetScoreDisplays();
            });

            let currentWinNum = 3;
            const winSubConNumInput = document.getElementById("winNumberInput");

            winConSelect.addEventListener("change", function () {
                const condition = winConSelect.value;
                if (condition != 'noWin' || condition != 'deathmatch' || condition != 'timedMatch') {
                    winSubConNumInput.style.opacity = 1;
                    winSubConNumInput.inert = false;
                    let p = prompt('Define the score that takes the win:', '3');
                    try {
                        parseInt(p);
                    }
                    catch {
                        p = '3';
                    }
                    winSubConNumInput.value = parseInt(p);
                }
                resetScoreDisplays();
                checkWinCondition(condition);
            });



            function getMatchTimer(elapsed) {
                const matchDuration = parseInt(document.getElementById("winNumberInput").value); // Duration of the match in minutes
                return (matchDuration * 60) - elapsed; // Calculate end time
            }

            // Check win condition
            function checkWinCondition(winCondition) {
                const winNumber = parseInt(document.getElementById("winNumberInput").value);

                switch (winCondition) {
                    case "noWin":
                        // No limit win condition - do nothing
                        break;
                    case "firstToX":
                        // First to score # points wins
                        if (scoreLeft >= winNumber || scoreRight >= winNumber) {
                            // End the game, display winner
                            endGame(scoreLeft > scoreRight ? "Left Player" : "Right Player");
                        }
                        if (subConNumLabel.style.display == 'none' || winNumber != currentWinNum) {
                            subConNumLabel.style.display = 'inline-flex';
                            currentWinNum = winNumber;
                            subConNumLabel.textContent = 'First To Score ' + winNumber + '!';
                        }
                        break;
                    case "bestOfX":
                        // Score more than 50% of # to win
                        const totalScore = winNumber % 2 === 0 ? (winNumber / 2) : Math.floor(winNumber / 2);
                        if ((scoreLeft > totalScore || scoreRight > totalScore)) {
                            // End the game, display winner
                            endGame(scoreLeft > scoreRight ? "Left Player" : "Right Player");
                        }
                        if (subConNumLabel.style.display == 'none' || winNumber != currentWinNum) {
                            subConNumLabel.style.display = 'inline-flex';
                            subConNumLabel.textContent = 'Score ' + (winNumber % 2 != 0 ? Math.ceil(winNumber / 2) : (Math.ceil(winNumber / 2) + 1)) + ' Points!';
                            currentWinNum = winNumber;

                        }
                        break;
                    case "deathmatch":
                        // First to score wins
                        if (scoreLeft > 0 || scoreRight > 0) {
                            // End the game, display winner
                            endGame(scoreLeft > scoreRight ? "Left Player" : "Right Player");
                        }
                        if (winSubConNumInput.style.display != 'none' || winNumber != 0 || subConNumLabel.textContent != 'First To Score!') {
                            subConNumLabel.style.display = 'inline-flex';
                            subConNumLabel.textContent = 'First To Score!';
                            winSubConNumInput.style.display = 'none';
                        }
                        break;
                    case "domination":
                        // Score # times in a row to win
                        const consecutiveWins = parseInt(document.getElementById("winNumberInput").value); // Number of consecutive wins required
                        const consecutiveWinner = (scoreLeft >= consecutiveWins) ? "leftPlayer" : (scoreRight >= consecutiveWins) ? "rightPlayer" : null;
                        if (consecutiveWinner) {
                            // Check if the consecutive wins condition is met
                            let leftConsecutive = 0;
                            let rightConsecutive = 0;
                            for (let i = 0; i < scoreHistory.length; i++) {
                                if (scoreHistory[i] === "leftPlayer") {
                                    leftConsecutive++;
                                    rightConsecutive = 0;
                                } else if (scoreHistory[i] === "rightPlayer") {
                                    rightConsecutive++;
                                    leftConsecutive = 0;
                                }
                                if (leftConsecutive >= consecutiveWins || rightConsecutive >= consecutiveWins) {
                                    // End the game, display winner
                                    endGame(consecutiveWinner);
                                    break;
                                }
                            }
                        }
                        if (subConNumLabel.style.display == 'none' || winNumber != currentWinNum) {
                            subConNumLabel.style.display = 'inline-flex';
                            currentWinNum = winNumber;
                            subConNumLabel.textContent = 'Score ' + winNumber + ' Back-to-Back!';
                        }
                        break;
                    case "timedMatch":
                        // Score the most points in # minutes to win
                        let endTime = 0;
                        if (subConNumLabel.style.display == 'none' || winNumber != currentWinNum) {
                            subConNumLabel.style.display = 'inline-flex';
                            subConNumLabel.textContent = 'Highest Score After' + winNumber + ' Minutes! ' + winNumber + ' Remaining!';
                            currentWinNum = winNumber;

                        }
                        const interval = setInterval(() => {
                            endTime++;
                            const et = getMatchTimer(endTime) / 60;
                            let tr = et.toPrecision(2);

                            subConNumLabel.textContent = 'Highest Score After' + winNumber + ' Minutes! ' + tr + ' Remaining!';
                            if (getMatchTimer(endTime) == 0) {
                                // End of match
                                clearInterval(interval); // Stop the interval
                                // Determine winner based on points
                                const winner = (scoreLeft > scoreRight) ? "Left Player" : (scoreRight > scoreLeft) ? "Right Player" : "Tie";
                                endGame(winner); // End the game and display winner
                            }
                        }, 1000); // Check every second
                        break;
                    default:
                        break;
                }
            }

            // End game
            function endGame(winner) {
                gameOver = true;
                alert("Game Over! Winner: " + winner);
                resetScoreDisplays();
                //checkWinCondition(winConSelect.value);
            };

            // Function to apply selected placeholder
            function applyGameMode(mode) {
                gameMode = mode;
                switch (mode) {
                    case "default":
                        fourPaddles();
                        break;
                    case "twoPaddles":
                        noTopBottomPaddles();
                        break;
                    case "fourPaddles":
                        fourPaddles();
                        break;
                    default:
                        break;
                }
            };

            /**
             * Returns the string-type name of the colour related to the 'type' name string of the power-up passed in.
             * @param {string} pwrType
             * @returns {string}
             */
            function getActivePowerUpColour(pwrType) {
                return pwrType === 'speedUp' ? "green" : (pwrType == '' ? 'white' : (pwrType === 'speedDown' ? "red" : (pwrType === 'ballBig' ? "cyan" : (pwrType === 'ballSmall' ? "orange" : pwrType === 'paddleShort' ? 'pink' : (pwrType === 'paddleTall' ? 'yellow' : 'white')))));
            };

            function drawArrow(context, x, y, width, height, color, angleInDegrees) {
                // Save the current transformation matrix
                context.save();
                // Rotate the canvas to the specified angle
                context.rotate(angleInDegrees);

                // Set arrow color
                context.fillStyle = color;
                context.strokeStyle = color;

                // Draw arrow triangle
                context.beginPath();
                context.moveTo(x, y);
                context.lineTo(x + width / 2, y + height);
                context.lineTo(x + width, y);
                context.closePath();
                context.fill();

                // Draw arrow line
                context.beginPath();
                context.lineWidth = width / 3;
                context.moveTo(x + (width / 2), y + (height / 4));
                context.lineTo(x + (width / 2), y - height);
                context.stroke();



                context.translate((Math.random() * x) * randomupdown(), (Math.random() * y) * randomupdown());


                // Restore the previous transformation matrix
                context.restore();
            };

            /**
             * Draw power-up object
             * @returns {nothing}
             */
            function drawPowerUp() {
                if (powerUp.active && powerupsEnabled) {
                    pwrup.fillStyle = getActivePowerUpColour(powerUp.type);
                    let udpu = powerUp.type.includes('Up') || powerUp.type.includes('Big') || powerUp.type.includes('Tall') ? 180 : 0;
                    drawArrow(pwrup, powerUp.x, powerUp.y, powerUp.width, powerUp.height, getActivePowerUpColour(powerUp.type), udpu);
                    pwrup.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                    powerUp.drawn = true;
                }
            };
            // Check collision between ball and power-up
            function checkPowerUpCollision() {
                if (powerUp.active && powerupsEnabled &&
                    ball.x + ballSize >= powerUp.x &&
                    ball.x - ballSize <= powerUp.x + (powerUp.width / 2) &&
                    ball.y + ballSize >= powerUp.y &&
                    ball.y - ballSize <= powerUp.y + (powerUp.height / 2)) {
                    ball.fill = getActivePowerUpColour(powerUp.type);
                    applyPowerUpEffect();
                    resetPowerUp();
                }
            };
            // Reset power-up position after collision
            function resetPowerUp() {
                if (powerupsEnabled) {
                    powerUp.active = false;
                    powerUp.drawn = false;
                    generatePowerUp();
                }
            };
            // Apply effect when ball hits power-up
            function applyPowerUpEffect() {
                if (powerupsEnabled) {
                    ball.fill = 'white';
                    ball.mod = '';
                    ballSize = ogBallSize;
                    ballSpeed = ((parseInt(ballSpeedInput.value)));
                    // Implement desired effects based on power-up type
                    switch (powerUp.type) {
                        case 'speedUp':
                            // Speed up the ball
                            ballSpeed *= 1.1;
                            ball.dx *= 1.1;
                            ball.dy *= 1.1;
                            paddleSpeed *= 1.1;
                            break;
                        case 'speedDown':
                            // Slow down the ball
                            ballSpeed /= 1.1;
                            ball.dx /= 1.1;
                            ball.dy /= 1.1;
                            paddleSpeed /= 1.1;
                            break;
                        case 'ballBig':
                            ballSize *= 1.25;
                            ballSpeed /= 1.25;
                            break;
                        case 'ballSmall':
                            ballSize *= 0.75;
                            ballSpeed *= 1.25;
                            break;
                        case 'paddleShort':
                            paddleHeight *= 0.85;
                            break;
                        case 'paddleTall':
                            paddleHeight *= 1.15;
                            break;
                        case '':
                            ballSpeed = parseInt(ballSpeedInput.value);
                            paddleSpeed = ballSpeed * 1.5; // Update paddle speed based on ball speed
                            paddleHeight = canvas.width / 6;
                            ballSize = ogBallSize;
                            ball.fill = ball.fill == '' ? 'white' : getActivePowerUpColour(powerUp.type);
                            break;
                        // Add more cases for additional power-up types as needed
                    }
                    paddleSpeed = ballSpeed * 1.5; // Update paddle speed based on ball speed
                    ball.mod = powerUp.type;
                    powerUp.drawn = false;
                    powerUp.active = false;
                }
            };
            // Generate random power-up
            function generatePowerUp() {
                if (powerupsEnabled) {
                    if ((ball.dx == 0 && ball.dy == 0) || powerUp.active || powerUp.drawn) {
                        return;
                    }
                    powerUp.active = true;
                    powerUp.x = (canvas.width / 2) + (paddleWidth + (Math.random() * ((canvas.width / 2.5) - powerUp.width) - paddleWidth) * randomupdown());
                    powerUp.y = (canvas.height / 2) + (Math.random() * ((canvas.height / 2.5) - (powerUp.height * 1.5)) * randomupdown());
                    // Randomly assign a type to the power-up
                    const types = ['speedUp', 'speedDown', 'ballBig', 'ballSmall', 'paddleShort', 'paddleTall']; // Add more types as needed
                    powerUp.type = types[Math.floor(Math.random() * types.length)];
                    // Interval for cycling through power-up types
                    const interval = (Math.random() * 500) * 10;
                    // Cycle through power-up types until collision with ball
                    const cycleInterval = setTimeout(() => {
                        powerUp.type = types[Math.floor(Math.random() * types.length)];
                        if (powerUp.type == ball.mod || powerUp.type == '' || powerUp.active == false || ball.mod == '' || powerUp.drawn == '') {
                            resetPowerUp();
                        }
                        else { drawPowerUp(); }
                    }, interval);
                    // Check collision with ball
                    const checkCollisionInterval = setInterval(() => {
                        if (ball.x + ballSize >= powerUp.x && ball.x - ballSize <= powerUp.x + powerUp.width &&
                            ball.y + ballSize >= powerUp.y && ball.y - ballSize <= powerUp.y + powerUp.height) {
                            applyPowerUpEffect();
                            clearInterval(checkCollisionInterval);
                            clearTimeout(cycleInterval);
                            resetPowerUp();
                        }
                    }, 50); // Check collision every 50 milliseconds
                }
            };

            // Clear canvas
            function clearCanvas() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            };

            // Update top and bottom paddles' positions
            function updateTopBottomPaddles() {
                topPaddle.x += topPaddle.dx;
                if (topPaddle.x < 0) topPaddle.x = 0;
                if (topPaddle.x + tbPaddleWidth > canvas.width) topPaddle.x = canvas.width - tbPaddleWidth;
                bottomPaddle.x += bottomPaddle.dx;
                if (bottomPaddle.x < 0) bottomPaddle.x = 0;
                if (bottomPaddle.x + tbPaddleWidth > canvas.width) bottomPaddle.x = canvas.width - tbPaddleWidth;
            };
            // Draw top and bottom paddles
            function drawTopBottomPaddles() {
                drawHorizontalPaddles(topPaddle.y, topPaddle.x);
                drawHorizontalPaddles(bottomPaddle.y, bottomPaddle.x);
            };

            // Update positions
            function update() {
                // Update left paddle
                leftPaddle.y += leftPaddle.dy;
                if (leftPaddle.y < 0) leftPaddle.y = 0;
                if (leftPaddle.y + paddleHeight > canvas.height) leftPaddle.y = canvas.height - paddleHeight;
                // Update right paddle
                rightPaddle.y += rightPaddle.dy;
                if (rightPaddle.y < 0) rightPaddle.y = 0;
                if (rightPaddle.y + paddleHeight > canvas.height) rightPaddle.y = canvas.height - paddleHeight;
                // Update top and bottom paddles
                updateTopBottomPaddles();
                // Update ball position
                ball.x += ball.dx;
                ball.y += ball.dy;
                // Check collision with walls
                if (gameMode == 'twoPaddles')
                    if (ball.y + (ballSize / 2) >= canvas.height - 1 || ball.y - (ballSize / 2) <= 1) {
                        ball.dy = -ball.dy;
                        document.getElementById('bounce').play();
                        return;
                    }
                // Check collision with paddles
                // Bounce off left
                if (
                    ball.x - ballSize - 1 <= leftPaddle.x + paddleWidth &&
                    ball.y >= leftPaddle.y - 1 &&
                    ball.y <= leftPaddle.y + paddleHeight + 1
                ) {
                    document.getElementById('snap').play();
                    // Calculate the paddle hit position relative to its height (0 at the top, 1 at the bottom)
                    const relativeIntersectY = (ball.y - leftPaddle.y) / paddleHeight;

                    // Calculate the bounce angle based on the relative hit position and paddle direction
                    const bounceAngle = (relativeIntersectY - 0.5) * Math.PI / 2;

                    // Adjust the ball's direction based on the paddle's movement direction
                    ball.dx = Math.abs(ball.dx);
                    ball.dy = Math.abs(ball.dy) * Math.cos(bounceAngle) * (leftPaddle.dy < 0 ? -1 : 1);
                    return;
                }
                // Bounce off right
                if (
                    ball.x + ballSize + 1 >= rightPaddle.x - paddleWidth &&
                    ball.y >= rightPaddle.y - 1 &&
                    ball.y <= rightPaddle.y + 1 + paddleHeight
                ) {
                    document.getElementById('snap').play();
                    // Calculate the paddle hit position relative to its height (0 at the top, 1 at the bottom)
                    const relativeIntersectY = (ball.y - rightPaddle.y) / paddleHeight;
                    // Calculate the bounce angle based on the relative hit position and paddle direction
                    const bounceAngle = (relativeIntersectY - 0.5) * Math.PI / 2;
                    // Adjust the ball's direction based on the paddle's movement direction
                    ball.dx = -Math.abs(ball.dx);
                    ball.dy = Math.abs(ball.dy) * Math.cos(bounceAngle) * (rightPaddle.dy < 0 ? -1 : 1);
                    return;
                }
                // Bounce off bottom
                if (
                    ball.y + ballSize + 1 >= bottomPaddle.y - (bottomPaddle.high * 2) &&
                    ball.x >= bottomPaddle.x - (bottomPaddle.wide) &&
                    ball.x <= bottomPaddle.x + (bottomPaddle.wide)) {
                    document.getElementById('snap').play();
                    ball.dy = 0 - ball.dy;
                    return;
                }
                // Bounce off top
                if (
                    ball.y - ballSize - 1 <= topPaddle.y + (topPaddle.high * 2) &&
                    ball.x >= topPaddle.x - (topPaddle.wide) &&
                    ball.x <= topPaddle.x + (topPaddle.wide)
                ) {
                    document.getElementById('snap').play();
                    ball.dy = Math.abs(ball.dy);
                    return;
                }
                // Score top
                if (ball.y - ballSize + 1 <= topPaddle.y - 1 - (topPaddle.high / 2)) {
                    document.getElementById('popmp3').play();
                    scoreRight++; // Increment bottom player score
                    updateScoreDisplay();
                    scoreHistory.push('rightPlayer')
                    powerUp.drawn = false;
                    resetBall();
                }
                // Score bottom
                if (ball.y + ballSize - 1 >= canvas.height) {
                    document.getElementById('popmp3').play();
                    scoreLeft++; // Increment top player score
                    updateScoreDisplay();
                    scoreHistory.push('leftPlayer')
                    powerUp.drawn = false;
                    resetBall();
                }
                // Check for scoring
                if (ball.x - ballSize + 1 <= leftPaddle.x - 1 - (paddleWidth / 2)) {
                    // Right player scores
                    document.getElementById('popmp3').play();
                    scoreRight++;
                    updateScoreDisplay();
                    scoreHistory.push('rightPlayer')
                    powerUp.drawn = false;
                    resetBall();
                }
                if (ball.x + ballSize - 1 >= rightPaddle.x + 1 + (paddleWidth / 2)) {
                    document.getElementById('popmp3').play();
                    // Left player scores
                    scoreLeft++;
                    updateScoreDisplay();
                    scoreHistory.push('leftPlayer')
                    powerUp.drawn = false;
                    resetBall();
                }
                checkWinCondition(winConSelect.value);
            };
            /**
             * returns a psuedo-random number, either -1 or +1.
             * useful to randomly invert a number via multiplication.
             * (amid any other concievable application of the result).
             * @returns
             */
            function randomupdown() {
                return (Math.random()) >= 0.5 ? 1 : -1;
            };
            // Reset ball position
            function resetBall() {
                //reset paddles dimensions to default size scaled to canvas size
                paddleHeight = canvas.width / 6;
                paddleWidth = (canvas.height * 2) / paddleHeight;
                // clear canvas and redraw paddles and ball
                clearCanvas();
                drawPaddle(leftPaddle.x, leftPaddle.y);
                drawPaddle(rightPaddle.x, rightPaddle.y);
                drawTopBottomPaddles();
                drawBall();
                //update ball position
                ball.x = canvas.width / 2;
                ball.y = canvas.height / 2;
                //stop ball from moving
                ball.dx = 0;
                ball.dy = 0;
                //start moving ball when spacebar pressed
            };
            document.addEventListener("keyup", function (event) {
                if (event.key == ' ') {
                    if (gameStarted) {
                        clearCanvas();
                        gameLoop();
                        gameStarted = false;
                        return;
                    }
                    //move ball at default speed as set by user inpit since being reset
                    const dx = parseInt(ballSpeedInput.value);
                    ballSpeed = dx;
                    //get random direction left or right
                    ball.dx = dx * randomupdown();
                    //get random angle up down
                    ball.dy = (Math.random() * (dx / 2)) * randomupdown();
                    ballSize = ogBallSize; // Reset ball size unconditionally
                    //reset ball color to white
                    ball.fill = ball.mod ? ball.fill : 'white';
                    //adjust oaddle speeds to default in relation to ball speed
                    paddleSpeed = ballSpeed * 1.25;
                    //generate a powerUp object
                    powerUp.active = false;
                    powerUp.drawn = false;
                    generatePowerUp();
                }
            });
            // Update score display
            function updateScoreDisplay() {
                scoreLeftDisplay.textContent = scoreLeft;
                scoreRightDisplay.textContent = scoreRight;
                const scoreLeftElement = document.getElementById("scoreLeft");
                const scoreRightElement = document.getElementById("scoreRight");
                const numericScoreLeft = parseInt(scoreLeftDisplay.textContent);
                const numericScoreRight = parseInt(scoreRightDisplay.textContent);
                // Display scores
                scoreLeftElement.style.backgroundColor = (numericScoreLeft > numericScoreRight) ? "green" : (numericScoreLeft < numericScoreRight) ? "red" : "yellow";
                scoreRightElement.style.backgroundColor = (numericScoreLeft < numericScoreRight) ? "green" : (numericScoreLeft > numericScoreRight) ? "red" : "yellow";
            };
            // Draw everything
            function draw() {
                clearCanvas();
                // Draw paddles
                drawPaddle(leftPaddle.x, leftPaddle.y);
                drawPaddle(rightPaddle.x, rightPaddle.y);
                updateTopBottomPaddles();
                drawTopBottomPaddles();
                // Draw ball
                drawBall(ball.x, ball.y);
                drawPowerUp();
            };

            let keystates = [false, false, false, false, false, false, false, false];
            let keyA = false, keyW = false, keyS = false, keyD = false, upArrow = false, downArrow = false, leftArrow = false, rightArrow = false;
            //let keystates = [keyA = false, keyW = false, keyS = false, keyD = false, upArrow = false, downArrow = false, leftArrow = false, rightArrow = false];
            //let keystate = [keyA, keyW, keyS, keyD, upArrow, downArrow, leftArrow, rightArrow]
            let keynames = ['a', 'w', 's', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];

            // Handle keyboard input
            document.addEventListener("keydown", function (event) {
                let nameof = keynames.indexOf(event.key);
                if (nameof == false || nameof > keynames.length || nameof == -1) {
                    return;
                }
                else {
                    keystates[nameof] = true;
                    keyIsDown(event.key);
                    //if (keystates[keynames.indexOf(event.key)]) {
                    //    keyIsDown(event.key);
                    //};
                }
            });

            /**
             * The 'Key<key>' variables work with the 'keystates[]' and 'keynames[]' arrays within the 'keydown' and 'keyup' event listeners for seamless alternation between key presses
             * - most notably the handling of conflicting keys and the switch between them in order of action.
             *  - this eliminates the need for repeated/subequent key presses to resume/reverse actions interuppted by conflicting key-presses whilst the initial key remains pressed.
             *
             * @param {string} pressedKey
             */
            function keyIsDown(pressedKey) {
                switch (pressedKey) {
                    case "w":
                        leftPaddle.dy = -paddleSpeed; // Move left paddle up
                        keyW = true;
                        break;
                    case "s":
                        leftPaddle.dy = paddleSpeed; // Move left paddle up
                        keyS = true;
                        break;
                    case "ArrowUp":
                        rightPaddle.dy = -paddleSpeed; // Move right paddle up
                        upArrow = true;
                        break;
                    case "ArrowDown":
                        rightPaddle.dy = paddleSpeed; // Move right paddle down
                        downArrow = true;
                        break;
                    case "a":
                        topPaddle.dx = -(paddleSpeed * 1.25); // Move top paddle left
                        keyA = true;
                        break;
                    case "d":
                        topPaddle.dx = paddleSpeed * 1.25; // Move top paddle right
                        keyD = true;
                        break;
                    case "ArrowLeft":
                        bottomPaddle.dx = -(paddleSpeed * 1.25); // Move bottom paddle left
                        leftArrow = true;
                        break;
                    case "ArrowRight":
                        bottomPaddle.dx = paddleSpeed * 1.25; // Move bottom paddle right
                        rightArrow = true;
                        break;
                    default:
                        break;
                }

            };

            document.addEventListener("keyup", function (event) {
                switch (event.key) {
                    case "w":
                        keyW = false;
                        leftPaddle.dy = 0; // Stop left paddle movement
                        if (keyS) keyIsDown('s');
                        break;
                    case "s":
                        keyS = false;
                        leftPaddle.dy = 0; // Stop left paddle movement
                        if (keyW) keyIsDown('w');
                        break;
                    case "ArrowUp":
                        upArrow = false;
                        rightPaddle.dy = 0; // Stop right paddle movement
                        if (downArrow) keyIsDown('ArrowDown');
                        break;
                    case "ArrowDown":
                        downArrow = false;
                        rightPaddle.dy = 0; // Stop right paddle movement
                        if (upArrow) keyIsDown('ArrowUp');
                        break;
                    case "a":
                        keyA = false;
                        topPaddle.dx = 0; // Stop top paddle movement
                        if (keyD) keyIsDown('d');
                        break;
                    case "d":
                        keyD = false;
                        topPaddle.dx = 0; // Stop top paddle movement
                        if (keyA) keyIsDown('a');
                        break;
                    case "ArrowLeft":
                        leftArrow = false;
                        bottomPaddle.dx = 0; // Stop bottom paddle movement
                        if (rightArrow) keyIsDown('ArrowRight');
                        break;
                    case "ArrowRight":
                        rightArrow = false;
                        bottomPaddle.dx = 0; // Stop bottom paddle movement
                        if (leftArrow) keyIsDown('ArrowLeft');
                        break;
                }
                keystates[keynames.indexOf(event.key)] = false;

            });

            let aiSpeed = paddleSpeed * (0.1 + (Math.random() * 0.8));
            // AI logic for controlling left and top paddles
            function controlAI() {
                aiPaddleSpeed = aiSpeed * (1 - ((Math.random() * 0.9) + 0.1));
                // Control left paddle
                if (ball.y < leftPaddle.y + paddleHeight / 2) {
                    // If ball is above the middle of the left paddle, move up
                    leftPaddle.dy = -aiSpeed;
                } else {
                    // If ball is below the middle of the left paddle, move down
                    leftPaddle.dy = aiSpeed;
                }

                // Control top paddle
                if (ball.x < topPaddle.x + topPaddle.wide / 2) {
                    // If ball is to the left of the middle of the top paddle, move left
                    topPaddle.dx = -aiSpeed;
                } else {
                    // If ball is to the right of the middle of the top paddle, move right
                    topPaddle.dx = aiSpeed;
                }
            };

            const aiToggleInput = document.getElementById('aiCheckbox');
            function toggleAI() {
                vsAI = vsAI ? false : true;
                if (!vsAI) {
                    topPaddle.dx = 0;
                    leftPaddle.dy = 0;
                }
            };

            function gameLoop() {
                if (vsAI) {
                    controlAI();
                }
                draw();
                checkPowerUpCollision();
                ballSpeed = 5;
                ballSpeed = ball.mod === 'speedUp' ? 3 * 1.2 : (ball.mod === 'speedDown' ? 3 * 0.8 : 5);
                update();
                requestAnimationFrame(gameLoop);
            };

            function nextLetterWithSound(ctxt, introText, index, indentX, x, y) {
                // Draw the letter
                const gradient = ctx.createRadialGradient(indentX - x, y - 12, 48, canvas.width - indentX, y - 12, 48);
                // Add three color stops
                gradient.addColorStop(0.1, "#00000090");
                gradient.addColorStop(0.2, "pink");
                gradient.addColorStop(0.5, "#a99aa99a");
                gradient.addColorStop(0.9, "green");
                ctxt.font = "48px Arial";
                ctxt.fillStyle = gradient;
                if (index >= introText.length - 1) {

                    ctxt.fillStyle = gradient;
                    ctxt.strokeStyle = gradient;
                    ctxt.lineWidth = 24;
                    document.getElementById('popmp3').play();
                    ctxt.beginPath();
                    ctxt.moveTo(indentX - x, y + 25);
                    ctxt.lineTo(indentX + (x * introText.length), y + 25);
                    ctxt.stroke();
                } else {
                    if (introText.charAt(index) == ' ') {
                        ctxt.fillText(introText.charAt(index), indentX + (x * index), y);
                        document.getElementById('bounce').play();
                        nextLetterWithSound(ctxt, introText, index + 1, indentX, x, y);
                    }
                    if (index % 2 == 0) {
                        document.getElementById('bounce').play();
                    } else {
                        document.getElementById('snap').play();
                    }
                }
                ctxt.fillText(introText.charAt(index), indentX + (x * index), y);
                index++;
            };

            // Intro Animation
            function introAnimation() {
                let ctxt = canvas.getContext('2d');
                let infoText = "Press 'SPACEBAR' to Continue";
                const powerupsText = ["_fast-ball_", "slow-ball_", "big-ball_", "little-ball_", 'long-paddles_', "short-paddles_"];
                const powerupColors = ['green', 'red', 'cyan', 'orange', 'yellow', 'pink']
                let introText = "SUPER PONG";
                let x = 48;
                x += (canvas.width / (introText.length)) / 48;
                let indentX = (canvas.width / x) * introText.length;
                let xx = canvas.width / infoText.length;
                let xxx = canvas.width / powerupsText.length;
                let y = canvas.height / 2;
                let index = 0;
                for (let k = 0; k < 1; k++) {
                    setTimeout(() => { }, 500);
                    ctxt.font = "24px Arial";
                    ctxt.fillStyle = 'white';
                    ctxt.textAlign = 'center';
                    ctxt.fillText(infoText, canvas.width / 2, y + (y / 2));
                };
                for (let i = 0; i < powerupsText.length; i++) {
                    let xxxx = xxx / powerupsText[i].length;
                    for (let j = 0; j < powerupsText[i].length; j++) {
                        setTimeout(() => {
                            ctxt.font = "12px Arial";
                            ctxt.fillStyle = powerupColors[i];
                            ctxt.fillText(powerupsText[i].charAt(j), (xxx * i) + (xxxx * j) + 1, y - (y / 2));
                        }, 1500);
                    };
                };
                let interval = setInterval(() => {
                    if (index > introText.length) {
                        clearInterval(interval);
                        gameStarted = true;
                        return;
                    }
                    nextLetterWithSound(ctxt, introText, index, indentX, x, y);
                    index++;
                }, 250);
            };

            window.onload = introAnimation();
        };
        {
            function celsiusToFahrenheit(degreesC) {
                return (degreesC * (9 / 5)) + 32;
            };

            function decimalToHex(decimalValue) {
                const clampedValue = Math.max(0, Math.min(decimalValue, 255));
                const quotient = Math.floor(clampedValue / 16);
                const remainder = clampedValue % 16;
                const hexQuotient = toHexDigit(quotient);
                const hexRemainder = toHexDigit(remainder);
                return hexQuotient + hexRemainder;
            };

            function toHexDigit(decimal) {
                // Define an array of hexadecimal digits
                const hexDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
                // Return the corresponding hexadecimal digit for the decimal value
                return hexDigits[decimal];
            };

            function colourWeightsToHex(weight) {
                return decimalToHex(weight);
            };

            function generateBRColor(value) {
                // Calculate red value based on distance from 212
                const red = Math.round(255 * Math.min(Math.abs(value - 212) / 180, 1)); // 180 is the maximum distance between 212 and 32

                // Calculate blue value based on distance from -212
                const blue = Math.round(255 * Math.min(Math.abs(value + 212) / 244, 1)); // 244 is the maximum distance between -212 and 32

                // Green value set to 0
                const green = 0;

                // Convert RGB values to hexadecimal
                const redHex = red.toString(16).padStart(2, '0');
                const greenHex = green.toString(16).padStart(2, '0');
                const blueHex = blue.toString(16).padStart(2, '0');

                // Construct RGBA hex color code
                const rgbaHex = `#${redHex}${greenHex}${blueHex}`;

                return rgbaHex;
            }
        };
    </script>
</body>
</html>
